<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Coin Ninja</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: none;
            touch-action: none; /* Prevent scrolling on mobile */
            user-select: none; /* Prevent text selection */
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #score {
            position: absolute;
            top: 30px;
            left: 30px;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #combo {
            position: absolute;
            top: 80px;
            left: 30px;
            font-size: 18px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #timer {
            position: absolute;
            top: 30px;
            right: 30px;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #timer.warning {
            color: #ff6666;
            animation: pulse 0.5s infinite;
        }

        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 300;
        }

        #finalScore {
            font-size: 64px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 20px;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
        }

        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #startScreen button,
        #playAgainButton {
            padding: 20px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            pointer-events: all;
            min-width: 200px;
            min-height: 60px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        #startScreen button:hover,
        #startScreen button:active,
        #playAgainButton:hover,
        #playAgainButton:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            background: linear-gradient(45deg, #ffed4e, #ffd700);
        }

        #countdownScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 300;
        }

        #countdownNumber {
            font-size: 120px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        #trail {
            position: absolute;
            pointer-events: none;
            z-index: 150;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .trail-segment {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ffffff 0%, #ffd700 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
        }

        .trail-line {
            position: absolute;
            background: linear-gradient(90deg, rgba(255,215,0,0.9) 0%, rgba(255,107,107,0.7) 100%);
            border-radius: 3px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            z-index: 199;
        }

        .points-animation {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 150;
            animation: floatUp 1s ease-out forwards;
        }

        .points-positive {
            color: #ffd700;
        }

        .points-negative {
            color: #ff4444;
            animation: shakeAndFloat 1s ease-out forwards;
        }

        @keyframes shakeAndFloat {
            0% {
                opacity: 1;
                transform: translateY(0px) scale(1) translateX(0px);
            }
            10% { transform: translateY(-10px) scale(1.1) translateX(-5px); }
            20% { transform: translateY(-20px) scale(1.2) translateX(5px); }
            30% { transform: translateY(-30px) scale(1.3) translateX(-3px); }
            40% { transform: translateY(-40px) scale(1.4) translateX(3px); }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5) translateX(0px);
            }
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(1.5);
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="trail"></div>
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="combo"></div>
            <div id="timer">45</div>
        </div>
        <div id="startScreen">
            <h1>Alt Token Ninja</h1>
            <button id="startButton">Start Game</button>
        </div>
        <div id="countdownScreen">
            <div id="countdownNumber">3</div>
            <p style="font-size: 24px; margin-top: 20px;">Get Ready!</p>
        </div>
        <div id="gameOverScreen">
            <h2 style="font-size: 48px; margin-bottom: 30px;">Game Over!</h2>
            <div id="finalScore">0</div>
            <div style="margin: 30px 0; color: #cccccc;">
                <div style="margin: 10px 0; font-size: 20px;">
                    <span style="color: #ffd700;">Alt Tokens Collected: </span>
                    <span id="goodTokens" style="color: #4caf50;">0</span>
                </div>
                <div style="margin: 10px 0; font-size: 20px;">
                    <span style="color: #ff6666;">Fake Tokens Hit: </span>
                    <span id="badTokens" style="color: #f44336;">0</span>
                </div>
                <div style="margin: 10px 0; font-size: 18px; color: #888;">
                    <span>Accuracy: </span>
                    <span id="accuracy">0%</span>
                </div>
            </div>
            <button id="playAgainButton">Start Game</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, coins = [], particles = [];
        let score = 0, combo = 0, comboTimer = 0;
        let gameStarted = false, gameTime = 45, gameTimer = null;
        let coinSpawners = []; // Track spawner intervals
        let goodTokensSliced = 0, badTokensSliced = 0; // Token statistics
        let mousePos = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        let trailPoints = [];
        let isMoving = false;
        let lastMoveTime = 0;

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1e3c72, 50, 200);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 30);

            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1e3c72);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Mouse and touch events
            setupMouseEvents();
            
            // Start button events
            setupStartButton();

            // Start render loop
            animate();
        }

        function setupStartButton() {
            const startButton = document.getElementById('startButton');
            const playAgainButton = document.getElementById('playAgainButton');
            
            // Handle start button
            startButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                resetGame();
                startCountdown();
            });
            
            startButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                resetGame();
                startCountdown();
            });
            
            // Handle play again button
            playAgainButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('gameOverScreen').style.display = 'none';
                resetGame();
                startCountdown();
            });
            
            playAgainButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('gameOverScreen').style.display = 'none';
                resetGame();
                startCountdown();
            });
        }

        function setupMouseEvents() {
            // Mouse events for desktop
            document.addEventListener('mousemove', handlePointerMove);
            
            // Touch events for mobile
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                handlePointerMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            }
        }

        function handleTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                handlePointerMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            }
        }

        function handleTouchEnd(event) {
            event.preventDefault();
            // Keep trail visible for a bit after touch end
        }

        function handlePointerMove(event) {
            lastMousePos.x = mousePos.x;
            lastMousePos.y = mousePos.y;
            
            mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Track movement
            isMoving = true;
            lastMoveTime = Date.now();
            
            // Always show trail, even before game starts
            updateTrail(event.clientX, event.clientY);
            
            if (gameStarted) {
                checkCoinSlicing();
            }
        }

        function updateTrail(x, y) {
            // Add new trail point
            trailPoints.push({ x, y, time: Date.now() });
            
            // Limit trail points for performance
            if (trailPoints.length > 15) {
                trailPoints = trailPoints.slice(-15);
            }
            
            // Update the visual trail
            updateTrailFading();
        }

        function showPointsAnimation(worldPos, points) {
            // Convert world position to screen coordinates
            const vector = worldPos.clone();
            vector.project(camera);
            
            const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            // Create points element
            const pointsElement = document.createElement('div');
            pointsElement.className = 'points-animation';
            
            if (points > 0) {
                pointsElement.textContent = '+' + points;
                pointsElement.classList.add('points-positive');
            } else {
                pointsElement.textContent = points.toString();
                pointsElement.classList.add('points-negative');
            }
            
            pointsElement.style.left = screenX + 'px';
            pointsElement.style.top = screenY + 'px';
            
            document.body.appendChild(pointsElement);
            
            // Remove after animation
            setTimeout(() => {
                if (pointsElement.parentNode) {
                    pointsElement.parentNode.removeChild(pointsElement);
                }
            }, 1000);
        }

        function createCoin() {
            const coinTypes = [
                { color: 0xffd700, value: 10, type: 'gold' },     // Gold
                { color: 0xc0c0c0, value: 5, type: 'silver' },   // Silver
                { color: 0xcd7f32, value: 3, type: 'bronze' },   // Bronze
                { color: 0x4169e1, value: 15, type: 'special' }, // Special blue
                { color: 0xff3333, value: -25, type: 'bomb' }    // Dangerous red bomb
            ];
            
            // 70% chance for good coins, 30% chance for bomb
            let type;
            if (Math.random() < 0.7) {
                type = coinTypes[Math.floor(Math.random() * 4)]; // Good coins only
            } else {
                type = coinTypes[4]; // Bomb coin
            }
            
            // Create coin geometry
            const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32);
            let material;
            
            if (type.type === 'bomb') {
                // Special material for bomb coins with pulsing effect
                material = new THREE.MeshPhongMaterial({
                    color: type.color,
                    shininess: 100,
                    specular: 0x444444,
                    emissive: 0x220000 // Slight red glow
                });
            } else {
                material = new THREE.MeshPhongMaterial({
                    color: type.color,
                    shininess: 100,
                    specular: 0x222222
                });
            }
            
            const coin = new THREE.Mesh(geometry, material);
            
            // Position coin at bottom of screen (wider spawn area)
            coin.position.x = (Math.random() - 0.5) * 50; // Wider spawn
            coin.position.y = -30; // Even lower starting position
            coin.position.z = (Math.random() - 0.5) * 15;
            
            // Add physics properties with much higher velocity for full screen height
            coin.velocity = {
                x: (Math.random() - 0.5) * 8, // Wider horizontal spread
                y: 35 + Math.random() * 15, // Much higher initial velocity (was 20-28, now 35-50)
                z: (Math.random() - 0.5) * 4
            };
            
            coin.angularVelocity = {
                x: (Math.random() - 0.5) * 0.2,
                y: (Math.random() - 0.5) * 0.2,
                z: (Math.random() - 0.5) * 0.2
            };
            
            coin.gravity = -0.3; // Less gravity for higher flight (was -0.4)
            coin.userData = { 
                value: type.value, 
                sliced: false, 
                type: type.type,
                pulseTime: 0 // For bomb pulsing effect
            };
            
            scene.add(coin);
            coins.push(coin);
        }

        function updateCoins() {
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                
                if (coin.userData.sliced && !coin.userData.isFragment) continue;
                
                // Update position
                coin.position.x += coin.velocity.x * 0.016;
                coin.position.y += coin.velocity.y * 0.016;
                coin.position.z += coin.velocity.z * 0.016;
                
                // Update rotation
                coin.rotation.x += coin.angularVelocity.x;
                coin.rotation.y += coin.angularVelocity.y;
                coin.rotation.z += coin.angularVelocity.z;
                
                // Apply gravity
                coin.velocity.y += coin.gravity * 0.016 * 60;
                
                // Bomb coin pulsing effect
                if (coin.userData.type === 'bomb' && !coin.userData.sliced) {
                    coin.userData.pulseTime += 0.1;
                    const pulseIntensity = 0.5 + 0.3 * Math.sin(coin.userData.pulseTime);
                    coin.material.emissive.setRGB(0.2 * pulseIntensity, 0, 0);
                    
                    // Scale pulsing
                    const scale = 1 + 0.1 * Math.sin(coin.userData.pulseTime * 2);
                    coin.scale.set(scale, scale, scale);
                }
                
                // Remove coins that are too low or too far to the sides
                if (coin.position.y < -35 || Math.abs(coin.position.x) > 60) {
                    scene.remove(coin);
                    coins.splice(i, 1);
                    
                    // Only reset combo for non-sliced, non-fragment coins
                    if (!coin.userData.sliced && !coin.userData.isFragment) {
                        combo = 0;
                        updateUI();
                    }
                }
            }
        }

        function checkCoinSlicing() {
            const mouseSpeed = Math.sqrt(
                Math.pow(mousePos.x - lastMousePos.x, 2) + 
                Math.pow(mousePos.y - lastMousePos.y, 2)
            );
            
            // More lenient speed requirement for mobile
            const isMobile = 'ontouchstart' in window;
            const minSpeed = isMobile ? 0.005 : 0.01;
            
            if (mouseSpeed < minSpeed) return; // Not moving fast enough
            
            coins.forEach(coin => {
                if (coin.userData.sliced) return;
                
                // Convert coin position to screen coordinates
                const vector = coin.position.clone();
                vector.project(camera);
                
                const coinScreenX = vector.x;
                const coinScreenY = vector.y;
                
                // Check if mouse path intersects coin (more generous hitbox for mobile)
                const distance = Math.sqrt(
                    Math.pow(coinScreenX - mousePos.x, 2) + 
                    Math.pow(coinScreenY - mousePos.y, 2)
                );
                
                const hitboxSize = isMobile ? 0.2 : 0.15; // Larger hitbox for mobile
                const requiredSpeed = isMobile ? 0.01 : 0.02; // Lower speed requirement for mobile
                
                if (distance < hitboxSize && mouseSpeed > requiredSpeed) {
                    sliceCoin(coin);
                }
            });
        }

        function sliceCoin(coin) {
            if (coin.userData.sliced) return;
            
            coin.userData.sliced = true;
            
            if (coin.userData.type === 'bomb') {
                // Handle bomb coin
                const penalty = coin.userData.value; // Already negative
                score = Math.max(0, score + penalty); // Don't go below 0
                combo = 0; // Reset combo completely
                comboTimer = 0;
                
                // Track bad token
                badTokensSliced++;
                
                // Show negative points animation
                showPointsAnimation(coin.position, penalty);
                
                // Create bomb explosion effect
                createBombEffect(coin.position);
                
                // Screen shake effect
                shakeScreen();
                
            } else {
                // Handle normal coin
                const basePoints = coin.userData.value;
                const comboBonus = combo > 1 ? Math.floor(basePoints * (combo * 0.2)) : 0;
                const totalPoints = basePoints + comboBonus;
                
                // Update score
                score += totalPoints;
                combo++;
                comboTimer = 120; // 2 seconds at 60fps
                
                // Track good token
                goodTokensSliced++;
                
                // Show points animation
                showPointsAnimation(coin.position, totalPoints);
                
                // Create slice effect
                createSliceEffect(coin.position);
            }
            
            // Make coin fragments
            createCoinFragments(coin);
            
            // Remove original coin immediately
            scene.remove(coin);
            const index = coins.indexOf(coin);
            if (index > -1) coins.splice(index, 1);
            
            updateUI();
        }

        function createSliceEffect(position) {
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.05);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                particle.velocity = {
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8,
                    z: (Math.random() - 0.5) * 8
                };
                
                particle.life = 60; // 1 second at 60fps
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function createBombEffect(position) {
            // Create more dramatic red explosion particles
            for (let i = 0; i < 40; i++) {
                const geometry = new THREE.SphereGeometry(0.08);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff3333 : 0xff6666,
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                particle.velocity = {
                    x: (Math.random() - 0.5) * 12,
                    y: (Math.random() - 0.5) * 12,
                    z: (Math.random() - 0.5) * 12
                };
                
                particle.life = 90; // 1.5 seconds at 60fps
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        function shakeScreen() {
            // Screen shake effect by moving camera slightly
            const originalPos = { x: camera.position.x, y: camera.position.y };
            let shakeIntensity = 0.5;
            let shakeDuration = 30; // 0.5 seconds at 60fps
            
            const shakeInterval = setInterval(() => {
                camera.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity;
                camera.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity;
                
                shakeIntensity *= 0.9; // Reduce shake over time
                shakeDuration--;
                
                if (shakeDuration <= 0) {
                    camera.position.x = originalPos.x;
                    camera.position.y = originalPos.y;
                    clearInterval(shakeInterval);
                }
            }, 16); // ~60fps
        }

        function createCoinFragments(coin) {
            // Create two realistic halves of the coin
            for (let i = 0; i < 2; i++) {
                // Create half-coin geometry (semicircle)
                const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16, 1, false, 0, Math.PI);
                const material = coin.material.clone();
                
                const fragment = new THREE.Mesh(geometry, material);
                
                // Position fragments
                fragment.position.copy(coin.position);
                fragment.rotation.copy(coin.rotation);
                
                // Offset the halves slightly
                const offset = i === 0 ? -0.3 : 0.3;
                fragment.position.x += offset;
                
                // Set different velocities for each half
                fragment.velocity = {
                    x: coin.velocity.x + (i === 0 ? -4 : 4),
                    y: coin.velocity.y + 1,
                    z: coin.velocity.z + (Math.random() - 0.5) * 3
                };
                
                fragment.angularVelocity = {
                    x: (Math.random() - 0.5) * 0.3,
                    y: (Math.random() - 0.5) * 0.3,
                    z: (Math.random() - 0.5) * 0.3
                };
                
                fragment.gravity = -0.5;
                fragment.userData = { value: 0, sliced: true, isFragment: true };
                
                scene.add(fragment);
                coins.push(fragment);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.position.x += particle.velocity.x * 0.016;
                particle.position.y += particle.velocity.y * 0.016;
                particle.position.z += particle.velocity.z * 0.016;
                
                particle.velocity.y -= 0.3; // Gravity
                particle.life--;
                
                particle.material.opacity = particle.life / 60;
                
                if (particle.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('timer').textContent = gameTime;
            
            // Add warning styling when time is low
            const timerElement = document.getElementById('timer');
            if (gameTime <= 10) {
                timerElement.classList.add('warning');
            } else {
                timerElement.classList.remove('warning');
            }
            
            const comboElement = document.getElementById('combo');
            if (combo > 1 && comboTimer > 0) {
                comboElement.textContent = `Combo: ${combo}x`;
                comboElement.style.display = 'block';
            } else {
                comboElement.style.display = 'none';
            }
        }

        function startCountdown() {
            // Hide all screens first
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('countdownScreen').style.display = 'flex';
            
            let count = 3;
            const countdownElement = document.getElementById('countdownNumber');
            let countdownInterval;
            
            // Function to update display
            function updateCountdown() {
                if (count > 0) {
                    countdownElement.textContent = count;
                    countdownElement.style.color = count === 1 ? '#ff6666' : '#ffffff';
                    countdownElement.style.animation = 'none';
                    countdownElement.offsetHeight; // Trigger reflow
                    countdownElement.style.animation = 'pulse 1s ease-in-out';
                    count--;
                } else {
                    countdownElement.textContent = 'GO!';
                    countdownElement.style.color = '#ffd700';
                    countdownElement.style.animation = 'none';
                    countdownElement.offsetHeight; // Trigger reflow
                    countdownElement.style.animation = 'pulse 1s ease-in-out';
                    setTimeout(() => {
                        clearInterval(countdownInterval);
                        startGame();
                    }, 1000);
                    return; // Stop the interval
                }
            }
            
            // Show first number immediately
            updateCountdown();
            
            // Continue countdown every second
            countdownInterval = setInterval(() => {
                if (count >= 0) {
                    updateCountdown();
                    if (count < 0) {
                        clearInterval(countdownInterval);
                    }
                }
            }, 1000);
        }

        function startGame() {
            // Ensure clean start
            gameStarted = false;
            
            // Clear any existing intervals first
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            coinSpawners.forEach(interval => clearInterval(interval));
            coinSpawners = [];
            
            // Now start the game
            gameStarted = true;
            gameTime = 45;
            document.getElementById('countdownScreen').style.display = 'none';
            document.body.style.cursor = 'none';
            
            // Update UI immediately
            updateUI();
            
            // Start game timer
            gameTimer = setInterval(() => {
                if (gameStarted) { // Double check game is still running
                    gameTime--;
                    updateUI();
                    
                    if (gameTime <= 0) {
                        endGame();
                    }
                }
            }, 1000);
            
            // Primary coin spawner - high frequency
            coinSpawners.push(setInterval(() => {
                if (gameStarted && Math.random() < 0.8) { // 80% chance
                    createCoin();
                    
                    // Sometimes spawn multiple coins at once
                    if (Math.random() < 0.3) {
                        setTimeout(() => { if (gameStarted) createCoin(); }, 100);
                    }
                    if (Math.random() < 0.15) {
                        setTimeout(() => { if (gameStarted) createCoin(); }, 200);
                    }
                }
            }, 500));
            
            // Secondary coin spawner for variety
            coinSpawners.push(setInterval(() => {
                if (gameStarted && Math.random() < 0.5) { // 50% chance
                    createCoin();
                }
            }, 750));
            
            // Burst spawner - occasional coin showers
            coinSpawners.push(setInterval(() => {
                if (gameStarted && Math.random() < 0.2) { // 20% chance for burst
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => { if (gameStarted) createCoin(); }, i * 150);
                    }
                }
            }, 2000));
        }

        function endGame() {
            gameStarted = false;
            
            // Clear all intervals
            clearInterval(gameTimer);
            coinSpawners.forEach(interval => clearInterval(interval));
            coinSpawners = [];
            
            document.body.style.cursor = 'auto';
            
            // Clear all coins and particles
            coins.forEach(coin => scene.remove(coin));
            particles.forEach(particle => scene.remove(particle));
            coins = [];
            particles = [];
            
            // Clear trail
            trailPoints = [];
            document.getElementById('trail').innerHTML = '';
            
            // Calculate accuracy
            const totalTokensSliced = goodTokensSliced + badTokensSliced;
            const accuracy = totalTokensSliced > 0 ? Math.round((goodTokensSliced / totalTokensSliced) * 100) : 0;
            
            // Show game over screen with statistics
            document.getElementById('finalScore').textContent = score;
            document.getElementById('goodTokens').textContent = goodTokensSliced;
            document.getElementById('badTokens').textContent = badTokensSliced;
            document.getElementById('accuracy').textContent = accuracy + '%';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function resetGame() {
            // Stop any existing game
            gameStarted = false;
            
            // Clear all intervals
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            coinSpawners.forEach(interval => clearInterval(interval));
            coinSpawners = [];
            
            // Clear all coins and particles
            coins.forEach(coin => scene.remove(coin));
            particles.forEach(particle => scene.remove(particle));
            coins = [];
            particles = [];
            
            // Reset game variables
            score = 0;
            combo = 0;
            comboTimer = 0;
            gameTime = 45;
            goodTokensSliced = 0;
            badTokensSliced = 0;
            trailPoints = [];
            
            // Clear trail visual
            document.getElementById('trail').innerHTML = '';
            
            // Reset cursor
            document.body.style.cursor = 'auto';
            
            updateUI();
        }

        function updateTrailFading() {
            // Check if we stopped moving
            if (Date.now() - lastMoveTime > 50) {
                isMoving = false;
            }
            
            // Continue updating trail to fade it out
            if (trailPoints.length > 0) {
                const trail = document.getElementById('trail');
                const maxAge = isMoving ? 300 : 150;
                
                // Remove old points
                trailPoints = trailPoints.filter(point => Date.now() - point.time < maxAge);
                
                // If we have points, redraw with current fading
                if (trailPoints.length > 0) {
                    trail.innerHTML = '';
                    
                    // Redraw lines
                    for (let i = 1; i < trailPoints.length; i++) {
                        const currentPoint = trailPoints[i];
                        const prevPoint = trailPoints[i - 1];
                        
                        const dx = currentPoint.x - prevPoint.x;
                        const dy = currentPoint.y - prevPoint.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        if (length < 2) continue;
                        
                        const line = document.createElement('div');
                        line.className = 'trail-line';
                        line.style.left = prevPoint.x + 'px';
                        line.style.top = prevPoint.y + 'px';
                        line.style.width = length + 'px';
                        line.style.height = '6px';
                        line.style.transformOrigin = '0 50%';
                        line.style.transform = `rotate(${angle}deg)`;
                        
                        const age = Date.now() - currentPoint.time;
                        const baseOpacity = Math.max(0, 1 - age / maxAge);
                        const movementFactor = isMoving ? 1 : 0.3;
                        line.style.opacity = baseOpacity * movementFactor;
                        
                        trail.appendChild(line);
                    }
                    
                    // Redraw dots
                    trailPoints.forEach((point, index) => {
                        if (index % 3 === 0) {
                            const dot = document.createElement('div');
                            dot.className = 'trail-segment';
                            dot.style.left = (point.x - 4) + 'px';
                            dot.style.top = (point.y - 4) + 'px';
                            
                            const age = Date.now() - point.time;
                            const baseOpacity = Math.max(0, 1 - age / maxAge);
                            const movementFactor = isMoving ? 1 : 0.3;
                            dot.style.opacity = baseOpacity * movementFactor;
                            
                            trail.appendChild(dot);
                        }
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Always update trail fading
            updateTrailFading();
            
            if (gameStarted) {
                updateCoins();
                updateParticles();
                
                // Update combo timer
                if (comboTimer > 0) {
                    comboTimer--;
                    if (comboTimer === 0) {
                        combo = 0;
                        updateUI();
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the game
        init();
    </script>
</body>
</html>
